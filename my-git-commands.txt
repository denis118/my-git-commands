/**************************************
Configuration
**/

git config --global user.name "имя пользователя"

git config --global user.email "адресс электронной почты пользователя"

git config --list       // проверить применились ли настройки

~/.gitconfig        // файл с настройками git



/**************************************
Repository
**/

git init        // при запуске этой команды в директории проекта она инициализируется как git репозиторий, в ней создаётся скрытая папка .git

git status        // показывает проиндексированные файлы и папки в репозитории ( а также файлы и папки, которые необходимо проиндексировать  ), указывает в какой ветке сейчас нахожусь

git add <file> <file>       // указывает, какие файлы нужно проиндексировать

git add .       // указывает проиндексировать все нуждающиеся в этом файлы

git reset HEAD <file name>        // отменяет последнюю индексацию для указанного файла, так что в ближайший коммит его изменения включены не будут

git commit -m "месседж коммита"       // сообщение коммита желательно писать на английском и в повелительном стиле типа 'Create file...', 'Delete <input> in form...' и т.д.

git commit --amend -m "исправленный текст месседжа"       // исправляет текст сообщения последнего коммита

git diff        // показывает, какие непроиндексированные изменения произошли в файлах

        --staged        // показывает проиндексированные изменения ( например, если изменения произошли за счёт отката, т.е. git о них уже знал )

git log       // показывает историю коммитов

        --oneline       // выводит сокращённые данные коммита (в виде одной строки)
        --author="Denis Tsap"       // выводит коммиты, сделанные конкретным человеком
        --name-only       // выводит только названия изменённых файлов
        --graph       // выводит дерево зависимостей для всех коммитов
        --reverse       // выводит коммиты в обратном хронологическом порядке (сначала старые)
        --after       // выводит коммиты, сделанные после определённой даты, например --after="1 week ago"
        --before        // выводит коммиты, сделанные до определённой даты
        -1        // показывает только последний коммит, а 'git log -2' покажет два последних коммита и т.д.

git show <commit hash>        // показывает изменения, которые были зафиксированы в указанном коммите

git checkout <file name>        // делает откат изменений до предыдущего коммита для указанного файла ( если файл был удалён, он востановится при условии, что ранее он уже был отслеживаемым )

git checkout <commit hash> <file name>        // делает откат изменений в конкретном файле до состояния, зафиксированного в указанном коммите

git checkout <commit hash>        // если передать только хеш коммита, то команда сделает откат для всего проекта до состояния, зафиксированного в указанном коммите

git rm --cached <pass to file>        // указывает убрать из закоммиченных конкретный файл ( может пригодится, если закоммитил всё, а потом передумал коммитить изменения в каком-то файле в данный момент ); файл при этом не пострадает
  git commit --amend --no-edit        // эта команда используется в связке с предыдущей и исполняется после неё для приведения последнего коммита, из которого только что исключили какой-то файл, в, так сказать, 'нормальное' состояние



/**************************************
Branches
**/

git cat-file -p <commit hash>       // выведет в консоль информацию об указанном коммите ( среди прочего там будет указан также и хэш родительского коммита )

git checkout -b <указатель коммита> <хэш коммита>       // переводит проект в состояние указанного коммита и присваивает этому коммиту указатель; от коммита, которому присвоили указатель, можно начать новую ветку, и называться она будет по имени того указателя

git log --oneline --all       // показывает все коммиты, таким образом можно увидеть где среди них я сейчас нахожусь ( обычно git показывает список коммитов только до того, в котором я нахожусь; если дальше тоже есть коммиты, без флага <--all> они видны не будут )

git merge <branch name> -m "<message>"        // производит слияние веток; чтобы влить какую-то ветку в master, нужно сначала перейти в master и потом уже вызвать команду слияния



// При возникновении конфликтов во время слияния нужно:
//        1. git status проверить в каких файлах есть конфликты
//        2. через редактор кода поочерёдно открыть и отредактировать каждый файл, оставив тот код, который является необходимым
//        3. сохранить изменения в файлах и вызвать для них git add
//        4. git commit -m "<message>" закоммитить изменения

// Если конфликт возник из-за того, что в одной ветке файл есть, а в другой удалён, нужно
//        
//        или оставить (
//                        git add <file name>
//                     )
//
//        или удалить  (
//                        git rm <file name>
//                     )
// В конце в любом случае нужно закоммитить изменения.



/**************************************
Origin
**/

git remote add origin git@github.com:<user nickname>/<repository name>.git      // добавляет удалённый репозиторий ( т. е. о нём будет знать локальный git; сам же репозиторий предварительно уже был создан на сайте гитхаба )

git remote -v       // проверяет, что репозиторий добавился

mkdir ~/.ssh        // ssh-ключи хранятся в указанной скрытой папке, если её нет, её нужно создать

ssh-keygen -t rsa -b 4096 -C "ts.dios.v@gmail.com"        // генерирует ssh-ключи, почта указывается таже, что и в настройках гита user.email

// Во время генерации ключам лучше дать имена, чтобы избежать путаницы при увеличении их колличества ( формат "имя-дата", например "github-05-10-2020" )

cat id_rsa.pub        // содержимое публичного ключа скопировать в настройки гитхаба

ssh -T -i ~/.ssh/id_rsa git@github.com        // проверить связь с гитхабом, он должен поздороваться и назвать меня по логину, если не поздоровался, может не того ключа значение скопировал или ещё что

ssh -T git@github.com       // проверить связь с гитхабом без указания ключа, результат должен быть такой, как и положительный результат от команды выше
                            // если появилось сообщение "Permission denied ( publickey )", нужно:
                                    1. открыть файл ~/.ssh/config ( если его нет, то создать и открыть )
                                    2. указать хост и прописать для него путь к приватному ssh-ключу:

                                    Host github.com
                                        ~/.ssh/id_rsa

                            // Первая строка без отступа, у второй - четыре пробела. Данная запись значит: для этого хоста использовать этот ключ

git push -u origin master       // отправит сохранённые локальные изменения в удалённый репозитоий в ветку master ( пушить можно в любую ветку )
                                // <-u> означает 'up stream' и устанавливает соединение между активной локальной веткой и удалённой, указанной в команде



/**************************************
Synchronization of two computers
**/

//  Для клонирования удалённого репозитория на компьютер нужно:
      1. в терминале перейты в директорию, в которую будет производиться клонирование
      2. на сайте гитхаба во вкладке для клонирования скопировать ссылку для случая с использованием ssh-ключей
      3. git clone <вставить скопированную ссылку>


git fetch origin        // получить все изменения из удалённого репозитория на локальный компьютер

// Если при git fetch загрузилась такая ветка, которой раньше небыло локально, то при попытке перейти в неё появится ошибка.

git checkout -b <имя новой локальной ветки> origin/<имя существующей удалённой ветки>       // нужно создать новую локальную ветку с именем, соответствующим имени удалённой, и переместить её указатель в тоже положение, где и укзатель origin/<имя существующей удалённой ветки>



git pull origin <имя удалённой ветки>        // если нужно в локальную ветку master получить файлы из какой-либо удалённой ветки, то сначала нужно проверить, что я нахожусь в локальной ветке master, а потом выполнить указанную команду, написав имя необходимой удалённой ветки

// Разница между pull и fetch:

                                pull - это fetch, после которого автоматически выполняется merge всех полученных изменений в активную ветку.

                                <git pull> == <git fetch> + <git merge FETCH_HEAD>

                                git fetch получает изменения с сервера и сохраняет их в каталог refs/remotes/.
                                Это никак не влияет на локальные ветки и текущие изменения. А git merge уже вливает все эти изменения в локальную копию.
                                Если в удалённом репозитории было изменено ветвление, то при выполнении git pull автоматическое слияние файлов не произойдёт из-за несоответствия ветвления локальной версии.



git push origin <имя локальной ветки>:<имя удалённой ветки>       // имена веток могут быть разными

git push origin :<имя неправильно названной удалённой ветки>       // если на гитхаб отправил неправильно названную ветку, то эта команда её удалит

git brunch -m <новое имя ветки>       // для переименования ветки сначала в неё нужно зайти

git branch --set-upstream-to=origin/<имя удалённой ветки>       // чтобы связать локальную и удалённую ветку и в дальнейшем для локальной использовать просто <git push> или <git pull>, нужно перейти в нужную локальную ветку и выполнить команду

git branch -vv        // посмотреть свзь локальных и удалённых веток



/**************************************
Push my code to someone else's repository
**/

1. Fork "someone else's repository"
2. Add new remote of my fork by using ssh-keys				// чтобы пушить свои локальные изменения в свой удалённый форк, а из него делать пулреквесты в сторонний проект
3. Add new remote of "someone else's repository" by using ssh-keys				// чтобы пулить изменения напрямую из стороннего проекта, так как мой удалённый форк и удалённый сторонний проект автоматически не синхронизируются

			git remote add <тут можно задать короткое имя для удалённого стороннего репозитория> git@github.com:<user nickname>/<repository name>.git 
                        git pull <имя для удалённого стороннего репозитория, которое я задал> <имя его удалённой ветки>
